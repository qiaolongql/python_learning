1、正则表达式
    |(管道符号)：从多个模式选择其中之一，如at|home 匹配字符串at、home
    .(点)：匹配除了换行符\n意外的任意字符。匹配点本身是用\.转义
    字符串边界：
        ^或\A:匹配字符串起始位置。如^from 匹配以from起始的字符串
        $或\Z:匹配字符串结束位置。如end$ 匹配以end结尾的字符串
    单词边界：
        \b:匹配一个单词的边界。如 \bthe 以the开始的字符串，\bthe\b 仅仅匹配单词the
        \B:匹配一个出现在单词中间的模式。\Bthe 任何包含但不以the为起始的字符串
    字符集:
        [...]:双大括号用于匹配包含于其中的任何字符。如[abc] 可以匹配abc三个字符中的任意一个
        -连接符:用于指定一个范围。如[A-Z] 匹配任一大写字母
        [^...]:反相匹配，即不匹配给定的字符集中的任何字符
    频数匹配：
        *:匹配0此或多次，即匹配任意次左侧表达式
        +:匹配1次或多次
        ?:匹配0次或1次
        {N}:匹配N次
        {M,N}:匹配M~匹配N次
    表示字符集的特殊字符:
        \w:匹配全部字母数字
        \d:匹配任何十进制数
        \s:匹配空格字符
        大写版本表示不匹配
    分组：
        ():用于对正则表达式进行分组，或匹配自组
        之所以需要分组是因为有时候我们需要使用通过模式匹配的字符来进行后续操作，
        而分组可以返回这些匹配的字符串
    扩展表示：
        扩展表示以(?...)开头
        (?:...):匹配后续模式，但这些匹配不会被保存；即对正则表达式分组但不会保存分组
        (?#...):不做匹配，只是作为注释
        (?=...):如果一个字符串后面跟着...才做匹配操作
        (?!...):如果一个字符串后面不是跟着...才做匹配操作
        (?<=...):如果字符串之前为...才做匹配操作
        (?<!...):如果字符串之前不是...才做匹配操作
        (?(1)y|x):如果一个匹配组1存在就与y匹配；否则与x匹配
    扩展符号：
        前面我们说过可以用re.IGNORECASE等标记，我们也可以直接使用(?标记)来直接使用
        i：不区分大小写
        s：使.匹配所有字符包括\n
        m：多行匹配
        x：忽略空白符

    *如果?紧跟在任何使用闭合操作符的匹配后边，它将直接要求正则表达式引擎匹配尽可能少的次数
     即匹配满足条件的最少字符，留下尽可能多的字符给后面的模式去匹配
    *可以使用(?P<name>...)和(?P=name...)来分组并未分组命名，不命名时我们可以通过\N来访问分组
     如\1,\2,\3而命名后我们可以通过\g<name>的形式来检索匹配的自组

2、re模块的核心函数和方法
    使用re模块需要先导入： import re
    ①、compile(pattern, flags=0)  编译正则表达式模式，返回一个正则表达式对象。
        参数：pattern  正则表达式模式
              flags  re.IGNORECASE|re.MULTILINE|re.DOTALL|re.VERBOSE
                     不区分大小写|使^$匹配行首行尾|使.匹配\n|
        用于将一个正则表达式模式预编译为一个正则表达式对象，当需要多次使用相同的模式
        在不同的地方进行匹配时可以使用同一个已经编译好的正则表达式对象来进行匹配
    ②、match(pattern, string, flags=0)
        参数：
            pattern 正则表达式模式
            string 要匹配的字符串
        返回值：
            成功  返回匹配对象
            失败  返回None
        match函数会试图从string字符串的起始开始匹配，如果可以完整匹配正则表达式则
        匹配成功，否则匹配失败。必须是从开始位置就匹配成功
        如 match('foo', 'food')  匹配成功 返回 'foo'
        match('foo', 'seafood')  匹配失败 返回 None
    ③、search(pattern, string, flags=0)
        参数：
            pattern 正则表达式模式
            string 要匹配的字符串
        返回值：
            成功  返回匹配对象
            失败  返回None
        search函数可以从字符串任意位置搜索第一次出现匹配的位置，然后返回
        如 search('foo', 'seafood')  匹配成功 返回 'foo'
    ④、匹配对象方法
        group()  返回整个匹配对象
        group(n)  返回匹配对象的第n个子组
        groups()  返回一个包含所有匹配子组的元组tuple，匹配失败返回空元组
        groupdict()  返回一个包含所有匹配的命名自组的字典，自组名称作为字典的键
        如 m = re.match('(\w\w\w)-(\d\d\d)', 'abc-123')
            m.group()  返回'abc-123'
            m.group(1) 返回'abc' m.group(2) 返回'123'
            m.groups() 返回('abc','123')

    ⑤、findall(pattern, string[,flags])
        参数：
            pattern 正则表达式模式
            string 要匹配的字符串
        返回值：
            成功  返回匹配列表
            失败  返回匹配列表(空)
        findall函数匹配所有出现的正则表达式模式(search值匹配第一次出现的)，
        并始终返回一个匹配列表，只不过当没有找到匹配时返回的是空列表

        *finditer(...)和findall函数一模一样，只不过它返回一个迭代器

    ⑥、使用sub()和subn()搜索和替换
        sub(pattern, repl, string, count=0)
            参数：
                pattern  正则表达式模式
                repl  用于替换查找到旧字符串的新字符串
                string 要检索的字符串
                count 可选 用于指定替换的个数
            返回值：
                返回替换后的string
        subn(pattern, repl, string)
            参数：
                pattern  正则表达式模式
                repl  用于替换查找到旧字符串的新字符串
                string 要检索的字符串
            返回值：
                返回一个元组tuple，包含(替换后的string，替换个数n)

        sub和subn使用repl替换所有正则表达式的模式在字符串中出现的位置(除非定义了count)
    ⑦、分隔字符串split
        split(pattern, string, max=0)
            参数：
                pattern 正则表达式的模式分隔符
                string 要分割的字符串
                max  最多分割次数
            返回值：
                返回一个包含分隔后字符的列表
        pattern中使用了()分隔组时，返回的分隔列表会包含分隔字符。如果想要分组又不想保存
        分隔字符在列表中可以使用(?:)